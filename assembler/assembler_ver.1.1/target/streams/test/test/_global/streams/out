[0m[[0m[0mdebug[0m] [0m[0mRunning TaskDef(assembler.data.IntSyntaxSpec, org.scalatest.tools.Framework$$anon$1@718a54ff, false, [SuiteSelector])[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning TaskDef(assembler.data.SymbolSpec, org.scalatest.tools.Framework$$anon$1@718a54ff, false, [SuiteSelector])[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning TaskDef(lib.syntax.StringSyntaxSpec, org.scalatest.tools.Framework$$anon$1@718a54ff, false, [SuiteSelector])[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning TaskDef(assembler.module.ParserModuleSpec, org.scalatest.tools.Framework$$anon$1@718a54ff, false, [SuiteSelector])[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning TaskDef(assembler.module.SymbolTableModuleSpec, org.scalatest.tools.Framework$$anon$1@718a54ff, false, [SuiteSelector])[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning TaskDef(assembler.data.AssemblyLineSpec, org.scalatest.tools.Framework$$anon$1@718a54ff, false, [SuiteSelector])[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning TaskDef(lib.syntax.OptionSyntaxSpec, org.scalatest.tools.Framework$$anon$1@718a54ff, false, [SuiteSelector])[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning TaskDef(lib.syntax.IntSyntaxSpec, org.scalatest.tools.Framework$$anon$1@718a54ff, false, [SuiteSelector])[0m
[0m[[0m[0minfo[0m] [0m[0m[32mSymbolSpec:[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mSymbol#findAddress[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m- should can find enum 'Symbol' by name.[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mOptionSyntaxSpec:[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mStrictOne[Option][0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m- should can set the EMPTY element to None.[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mExtension strict[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m- should can call from Option[A].[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mIntSyntaxSpec:[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mDest#findByOperand[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m- should can to find Dest by operand.[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mComp#findByOperand[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m- should can to find Comp by operand.[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mJump#findByOperand[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m- should can to find Jump by operand.[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mAssemblyLineSpec:[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mAssignedA#binary[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m- should can convert Int to Seq[Boolean][0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mAssignedC#binary[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m- should can convert Dest, Comp, Jump to Seq[Boolean][0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mStringSyntaxSpec:[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mBinaryConvertor[String][0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m- should Can convertes String to Array[Boolean].[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mExtension binary[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m- should can call from String.[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mIntSyntaxSpec:[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mBinaryContertor[Int][0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m- should can convert Int to Seq[Boolean].[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mSymbolTableModuleSpec:[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mSymbolTable#assignAddress[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m- should Can be assigned to address assembler symbols.[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mParserModuleSpec:[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mmoldAssemblyParser[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m- should can padding assembly code.[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mlabelParser[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m- should can extract the jump destination of hack assembler.[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m- should fails if not enclosed in parentheses or if the first character is a number.[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32minstructionAParser[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m- should can extract 'A instruction' of hack assembler.[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m- should fails if leading @ is not present or if a number is entered after @.[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32minstructionCParser[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m- should can extract 'C instruction' of hack assembly.[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m- should fails when a non mnemonic C instruction is received.[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[36mRun completed in 825 milliseconds.[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[36mTotal number of tests run: 19[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[36mSuites: completed 8, aborted 0[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[36mTests: succeeded 19, failed 0, canceled 0, ignored 0, pending 0[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mAll tests passed.[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mPassed tests:[0m
[0m[[0m[0mdebug[0m] [0m[0m	lib.syntax.IntSyntaxSpec[0m
[0m[[0m[0mdebug[0m] [0m[0m	lib.syntax.OptionSyntaxSpec[0m
[0m[[0m[0mdebug[0m] [0m[0m	assembler.data.IntSyntaxSpec[0m
[0m[[0m[0mdebug[0m] [0m[0m	assembler.module.SymbolTableModuleSpec[0m
[0m[[0m[0mdebug[0m] [0m[0m	assembler.module.ParserModuleSpec[0m
[0m[[0m[0mdebug[0m] [0m[0m	assembler.data.SymbolSpec[0m
[0m[[0m[0mdebug[0m] [0m[0m	assembler.data.AssemblyLineSpec[0m
[0m[[0m[0mdebug[0m] [0m[0m	lib.syntax.StringSyntaxSpec[0m
